//==============================================================================
//
// File:		LDrawLSynth.m
//
// Purpose:		A container directive representing LSynth bendable parts such as pipes,
//              tubes, string, chains and treads.  This class manages the constraints
//              used by LSynth, as well as the synthesized parts generated by LSynth.
//
//==============================================================================

#import "LDrawLSynth.h"
#import "LSynthConfiguration.h"
#import "LDrawPart.h"
#import "LDrawUtilities.h"
#import "StringCategory.h"
#import "LDrawKeywords.h"
#import "LDrawApplication.h"
#import "LDrawLSynthDirective.h"
#import "ComputationalGeometry.h"
#import "MatrixMath.h"
#import "MacLDraw.h"
#import "RegexKitLite.h"
#import "PreferencesDialogController.h"
#import "UserDefaultsCategory.h"

@implementation LDrawLSynth

#pragma mark -
#pragma mark INITIALIZATION
#pragma mark -

//========== init ==============================================================
//
// Purpose:		Creates a new container with absolutely nothing in it, but
//				ready to receive objects.
//
//==============================================================================
- (id) init
{
    self = [super init];

    if (self) {
        synthesizedParts = [[NSMutableArray alloc] init];
        self->synthType  = [[NSString alloc] init];
        color            = [[LDrawColor alloc] init];
        
        self->cachedBounds = InvalidBox;
        [self invalCache:CacheFlagBounds];
    }

    // Observe changes in selection display options
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(selectionDisplayOptionsDidChange:)
                                                 name:LSynthSelectionDisplayDidChangeNotification
                                               object:nil];

    // Observe requests for resynthesis
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(requiresResynthesis:)
                                                 name:LSynthResynthesisRequiredNotification
                                               object:nil];

    return self;
}//end init

//========== initWithLines:inRange:parentGroup: ================================
//
// Purpose:		Initializes the synthesized part with the supplied range of lines
//
// LSynth format is
//
// 0 SYNTH BEGIN <SYNTH_TYPE> <COLOR_CODE>
// 0 SYNTH SHOW
// 1 <CONSTRAINT PART>
// 0 SYNTH INSIDE/OUTSIDE
// ...
//
// <OPTIONALLY:>
// 0 SYNTH SYNTHESIZED BEGIN
// 1 <SYNTHESIZED PART SPEC>
// ...
// 0 SYNTH SYNTHESIZED END
// 0 SYNTH END
//
//==============================================================================
- (id) initWithLines:(NSArray *)lines
             inRange:(NSRange)range
         parentGroup:(dispatch_group_t)parentGroup
{
    NSString          *currentLine         = nil;
    Class              CommandClass        = Nil;
    NSRange            commandRange        = range;
    NSUInteger         lineIndex           = 0;
    LSynthParserStateT parserState         = PARSER_READY_TO_PARSE;

    self = [self init]; // Basic initialisation, not related to parsing
    self = [super initWithLines:lines inRange:range parentGroup:parentGroup];

    if(self)
    {
        lineIndex = range.location;

        while(lineIndex < NSMaxRange(range))
        {
            currentLine = [lines objectAtIndex:lineIndex];

            //
            // '0 SYNTH' directives
            //

            // 0 SYNTH BEGIN <SYNTH_TYPE> <COLOR>
            if ([currentLine isMatchedByRegex:@"0\\s+SYNTH\\s+BEGIN\\s+(\\S+?)\\s+(\\S+)"] &&
                parserState == PARSER_READY_TO_PARSE)  {

                NSArray *paramMatches = [currentLine arrayOfCaptureComponentsMatchedByRegex:@"0\\s+SYNTH\\s+BEGIN\\s+(\\S+?)\\s+(\\S+)"];

                NSString *type = [[paramMatches objectAtIndex:0] objectAtIndex:1];
                NSString *synthColor = [[paramMatches objectAtIndex:0] objectAtIndex:2];

                [self setLsynthType:type];
                [self setLDrawColor:[[ColorLibrary sharedColorLibrary] colorForCode:(LDrawColorT) [synthColor integerValue]]];

                [[[LDrawApplication shared] lsynthConfiguration] setLSynthClassForDirective:self withType:type];
                parserState = PARSER_PARSING_BEGUN;
            }

            // 0 SYNTH END - Synthesized parts may or may not be present
            else if ([currentLine isMatchedByRegex:@"0\\s+SYNTH\\s+END"] &&
                    (parserState == PARSER_PARSING_CONSTRAINTS ||
                     parserState == PARSER_SYNTHESIZED_FINISHED)) {
                parserState = PARSER_FINISHED;
            }

            // 0 SYNTH SHOW or
            // 0 SYNTH HIDE
            else if([currentLine isMatchedByRegex:@"0\\s+SYNTH\\s+(?:SHOW|HIDE)"] &&
               parserState == PARSER_PARSING_BEGUN) {
                parserState = PARSER_PARSING_CONSTRAINTS;
            }

            // 0 SYNTH SYNTHESIZED BEGIN - start of synthesized constraints
            else if ([currentLine isMatchedByRegex:@"0\\s+SYNTH\\s+SYNTHESIZED\\s+BEGIN"] &&
                    parserState == PARSER_PARSING_CONSTRAINTS) {
                parserState = PARSER_PARSING_SYNTHESIZED;
            }

            // 0 SYNTH SYNTHESIZED BEGIN - end of synthesized constraints
            else if ([currentLine isMatchedByRegex:@"0\\s+SYNTH\\s+SYNTHESIZED\\s+END"] &&
                    parserState == PARSER_PARSING_SYNTHESIZED) {
                parserState = PARSER_SYNTHESIZED_FINISHED;
            }

            // 0 SYNTH INSIDE or
            // 0 SYNTH OUTSIDE or
            // 0 SYNTH CROSS
            else if (parserState == PARSER_PARSING_CONSTRAINTS &&
                [currentLine isMatchedByRegex:@"0\\s+SYNTH\\s+(INSIDE|OUTSIDE|CROSS)"]) {

                NSString *direction = [[[currentLine arrayOfCaptureComponentsMatchedByRegex:@"(INSIDE|OUTSIDE|CROSS)"] objectAtIndex:0] objectAtIndex:0];
                LDrawLSynthDirective *directive = [[LDrawLSynthDirective alloc] init];
                [directive setStringValue:direction];
                [[self subdirectives] addObject:directive];
                [directive setEnclosingDirective:self];
                [directive addObserver:self];
            }

            //
            // '1 XXX' Part directives - constraints or synthesized parts
            //

            else if ([currentLine isMatchedByRegex:@"^1\\s+"] &&
                     (parserState == PARSER_PARSING_BEGUN ||
                      parserState == PARSER_PARSING_CONSTRAINTS ||
                      parserState == PARSER_PARSING_SYNTHESIZED)) {

                // Either way, create a part
                CommandClass = [LDrawUtilities classForDirectiveBeginningWithLine:currentLine];
                commandRange = [CommandClass rangeOfDirectiveBeginningAtIndex:lineIndex
                                                                      inLines:lines
                                                                     maxIndex:NSMaxRange(range) - 1];

                LDrawDirective *newDirective = [[CommandClass alloc] initWithLines:lines inRange:commandRange parentGroup:parentGroup];
                [newDirective setEnclosingDirective:self];
                [newDirective addObserver:self];

                // Add our part in the correct place
                if (parserState == PARSER_PARSING_CONSTRAINTS) {
                    [newDirective setIconName:[self determineIconName:newDirective]];
                    [[self subdirectives] addObject:newDirective];
                }

                else if (parserState == PARSER_PARSING_SYNTHESIZED) {
                    [synthesizedParts addObject:newDirective];
                }
            }

            //
            // Unrecognized or inappropriate directive at this point
            //

            else {
                NSLog(@"Unexpected line in LSynth definition at line %lu: %@ (state: %i)", (long)(lineIndex + 1), currentLine, parserState);
            }

            lineIndex += 1;
        }
    }

    // If we've read in synthesized parts or don't have any constraints then don't initially synthesize
    if ([synthesizedParts count] == 0 && [[self allEnclosedElements] count] > 0) {
        [self invalCache:ContainerInvalid];
    }

    [[NSNotificationCenter defaultCenter]
            postNotificationName:LDrawDirectiveDidChangeNotification
                          object:self];



    return self;

}//end initWithLines:inRange:

//========== lineIsLSynthBeginning: ===========================================
//
// Purpose:		Returns if line is a 0 SYNTH START
//
//==============================================================================
+ (BOOL) lineIsLSynthBeginning:(NSString*)line
{
    if ([line isMatchedByRegex:@"0\\s+SYNTH\\s+BEGIN\\s+\\S+?\\s+\\S+"]) {
        return YES;
    }
    return NO;
} //end lineIsLSynthBeginning:

//========== lineIsLSynthTerminator: ==========================================
//
// Purpose:		Returns if line is a 0 SYNTH END or 0 SYNTH PART (which are single
//              line directives)
//
//==============================================================================
+ (BOOL) lineIsLSynthTerminator:(NSString*)line
{
    if ([line isMatchedByRegex:@"0\\s+SYNTH\\s+END"]) {
        return YES;
    }
    return NO;
} //end lineIsLSynthTerminator:

//---------- rangeOfDirectiveBeginningAtIndex:inLines:maxIndex: ------[static]--
//
// Purpose:		Returns the range from the beginning to the end of the step.
//              i.e. 0 SYNTH END
//
//------------------------------------------------------------------------------
+ (NSRange) rangeOfDirectiveBeginningAtIndex:(NSUInteger)index
                                     inLines:(NSArray *)lines
                                    maxIndex:(NSUInteger)maxIndex
{
    NSString	*currentLine;
    NSUInteger	counter      = 0;
    NSRange 	testRange    = NSMakeRange(index, maxIndex - index + 1);
    NSInteger	synthLength	 = 0;
    NSRange 	synthRange;

    currentLine = [lines objectAtIndex:index];
    if ([currentLine isMatchedByRegex:@"0\\s+SYNTH\\s+BEGIN\\s+\\S+?\\s+\\S+"]) {

        // Find the last line in the synth definition: 0 SYNTH END
        for(counter = testRange.location + 1; counter < NSMaxRange(testRange); counter++)
        {
            currentLine = [lines objectAtIndex:counter];
            synthLength += 1;

            if([self lineIsLSynthTerminator:currentLine])
            {
                // Nothing more to parse. Stop.
                synthLength += 1;
                break;
            }
        }
    }

    synthRange = NSMakeRange(index, synthLength);

    return synthRange;
}//end rangeOfDirectiveBeginningAtIndex:inLines:maxIndex:

//========== initWithCoder: ====================================================
//
// Purpose:		Reads a representation of this object from the given coder,
//				which is assumed to always be a keyed decoder. This allows us to
//				read and write LDraw objects as NSData.
//
//==============================================================================
- (id) initWithCoder:(NSCoder *)decoder
{
    // Initialize the object.  We'll have somewhere to synthesize into.
    if (!(self = [self init])) return nil;

    // Container Coder initialization.  This repopulates our contained objects
    self = [super initWithCoder:decoder];

    // Reinitialize LSynth-specific attributes
    [self setLsynthClass:[decoder decodeIntForKey:@"lsynthClass"]];
    [self setLsynthType:[decoder decodeObjectForKey:@"synthType"]];
    [self setLDrawColor:[decoder decodeObjectForKey:@"color"]];

    // Constraints' icons should have been encoded/decoded correctly so we do
    // nothing in that respect.

    // Ask for resynthesis since we don't preserve synthesized parts during a copy/paste
    [self invalCache:ContainerInvalid];

    return self;

}//end initWithCoder:


//========== encodeWithCoder: ==================================================
//
// Purpose:		Writes a representation of this object to the given coder,
//				which is assumed to always be a keyed decoder. This allows us to
//				read and write LDraw objects as NSData.
//
//              We don't store synthesized parts since they'll be recreated when
//              we initWithCoder.
//
//==============================================================================
- (void)encodeWithCoder:(NSCoder *)encoder
{
    // Encode container-related stuff: containedObjects etc.
    [super encodeWithCoder:encoder];

    [encoder encodeInt:lsynthClass forKey:@"lsynthClass"];
    [encoder encodeObject:synthType forKey:@"synthType"];
    [encoder encodeObject:color forKey:@"color"];

}//end encodeWithCoder:


#pragma mark -
#pragma mark DISPLAY
#pragma mark -

//========== inspectorClassName ================================================
//
// Purpose:		Returns the name of the class used to inspect this one.
//
//==============================================================================
- (NSString *) inspectorClassName
{
    return @"InspectionLSynth";

}//end inspectorClassName

#pragma mark -
#pragma mark DIRECTIVES
#pragma mark -

//========== insertDirective:atIndex: ==========================================
//
// Purpose:		Inserts the new directive into the step.
//
//==============================================================================
- (void) insertDirective:(LDrawDirective *)directive atIndex:(NSInteger)index
{
    [self setSelected:NO]; // Explicitly deselect ourselves.  The newly added constraint gets selected.
    
    // Pick a badge icon depending on the LSynth class (band or hose)
    [directive setIconName:[self determineIconName:directive]];

    [super insertDirective:directive atIndex:index];
    [self invalCache:CacheFlagBounds|DisplayList|ContainerInvalid];

}//end insertDirective:atIndex:

//========== removeDirective: ==================================================
//
// Purpose:		Remove a contained directive (constraint etc.) and resynthesize
//
//==============================================================================
- (void) removeDirective:(LDrawDirective *)doomedDirective
{
    // We can leave removal to the base class
    [super removeDirective:doomedDirective];

    // TODO: Should we select the constraint at the previous index?
    [self setSubdirectiveSelected:NO];
    [self setSelected:NO]; // remove ourselves from the selection so that we can be selected by the user.
    [self invalCache:ContainerInvalid];
    
    [[NSNotificationCenter defaultCenter]
            postNotificationName:LDrawDirectiveDidChangeNotification
                          object:self];
}

//========== draw:viewScale:parentColor: =======================================
//
// Purpose:		Draw the synthesized part.
//
//==============================================================================
- (void) drawSelf:(id<LDrawRenderer>)renderer
{
    NSArray         *constraints         = [self subdirectives];
    LDrawDirective  *currentDirective    = nil;

    if(self->hidden == NO)
    {
        // Draw each constraint, if:
        if ([self isSelected] == YES ||               // We're selected
                self->subdirectiveSelected != NO ||   // A subdirective (constraint) is selected
                self->lsynthClass == LSYNTH_BAND ||   // We're a Band, so show constraints regardless
                (self->lsynthClass == LSYNTH_PART &&  // We're a Band PART
                 [self partClass] == LSYNTH_BAND)
                ) {
            for(currentDirective in constraints)
            {
                [currentDirective drawSelf:renderer];
            }
        }

        // Resynthesize if we've been invalidated (by e.g. any of our constraints moving)
        // This is the only place we invoke synthesis.  While it may incur a small delay in drawing
        // it's lazy (in a good way), and means resynthesis only occurs when we actually need it.
        if([self revalCache:ContainerInvalid] == ContainerInvalid) {
            [self synthesize];
            [self colorSelectedSynthesizedParts:([self isSelected] || self->subdirectiveSelected == YES)];
        }

        // Draw any synthesized parts as well
        for(currentDirective in synthesizedParts)
        {
            [currentDirective drawSelf:renderer];
        }
    }

}//end drawSelf:

//========== hitTest:transform:viewScale:boundsOnly:creditObject:hits: =======
//
// Purpose:		Hit-test the geometry.
//
//==============================================================================
- (void) hitTest:(Ray3)pickRay
       transform:(Matrix4)transform
       viewScale:(float)scaleFactor
      boundsOnly:(BOOL)boundsOnly
    creditObject:(id)creditObject
            hits:(NSMutableDictionary *)hits
{
    if(self->hidden == NO)
    {
        NSArray     *steps              = [self subdirectives]; // i.e. constraints
        LDrawPart   *currentDirective   = nil;
        NSUInteger  counter             = 0;


        // Hit test the constraints first since this will be the quicker test
        for(counter = 0; counter < [steps count]; counter++)
        {
            currentDirective = [steps objectAtIndex:counter];
            [currentDirective hitTest:pickRay
                            transform:transform
                            viewScale:scaleFactor
                           boundsOnly:boundsOnly
                         creditObject:currentDirective
                                 hits:hits];
        }

        // Now do the synthesized pieces.  We take the credit.  Thangyouverehmuch.
        for (LDrawPart *part in synthesizedParts) {
            [part hitTest:pickRay
                transform:transform
                viewScale:scaleFactor
               boundsOnly:boundsOnly
             creditObject:self
                     hits:hits];
        }
    }
}//end hitTest:transform:viewScale:boundsOnly:creditObject:hits:

//========== boxTest:transform:viewScale:boundsOnly:creditObject:hits: =======
//
// Purpose:		Check for intersections with screen-space geometry.
//
//==============================================================================
- (BOOL)    boxTest:(Box2)bounds
          transform:(Matrix4)transform
         boundsOnly:(BOOL)boundsOnly
       creditObject:(id)creditObject
               hits:(NSMutableSet *)hits
{
    NSArray     *commands			= [self subdirectives];
    NSUInteger  commandCount        = [commands count];
    LDrawPart   *currentDirective   = nil;
    NSUInteger  counter             = 0;

    // Do constraints
    for(counter = 0; counter < commandCount; counter++)
    {
        currentDirective = [commands objectAtIndex:counter];
        if ([currentDirective boxTest:bounds
                            transform:transform
                           boundsOnly:boundsOnly
                         creditObject:self
                                 hits:hits]) {
            if(creditObject != nil) {
                return TRUE;
            }
        };
    }

    // Also check synthesized parts
    for (LDrawPart *part in synthesizedParts) {
        if ([part boxTest:bounds
                transform:transform
               boundsOnly:boundsOnly
             creditObject:self
                     hits:hits]) {
            if(creditObject != nil) {
                return TRUE;
            }
        };
    }

    return FALSE;
}//end boxTest:transform:viewScale:boundsOnly:creditObject:hits:

//========== depthTest:inBox:transform:creditObject:bestObject:bestDepth:=======
//
// Purpose:		depthTest finds the closest primitive (in screen space)
//				overlapping a given point, as well as its device coordinate
//				depth.
//==============================================================================
- (void)	depthTest:(Point2) testPt
                inBox:(Box2)bounds
            transform:(Matrix4)transform
         creditObject:(id)creditObject
           bestObject:(id *)bestObject
            bestDepth:(float *)bestDepth
{
    NSArray     *commands			= [self subdirectives];
    NSUInteger  commandCount        = [commands count];
    LDrawPart   *currentDirective   = nil;
    NSUInteger  counter             = 0;

    for(counter = 0; counter < commandCount; counter++)
    {
        currentDirective = [commands objectAtIndex:counter];
        [currentDirective depthTest:testPt
                              inBox:bounds
                          transform:transform
                       creditObject:creditObject
                         bestObject:bestObject
                          bestDepth:bestDepth];
    }

    // Now do the synthesized pieces.  We take the credit.
    for (LDrawPart *part in synthesizedParts) {
        [part depthTest:testPt
                  inBox:bounds
              transform:transform
           creditObject:self
             bestObject:bestObject
              bestDepth:bestDepth];
    }

}//end depthTest:inBox:transform:creditObject:bestObject:bestDepth:

//========== write =============================================================
//
// Purpose:		Write out all the commands in the part
//
//==============================================================================
- (NSString *) write
{
    NSMutableString *written        = [NSMutableString string];
    NSString        *CRLF           = [NSString CRLF];
    NSString        *lsynthVisibility = @"SHOW";
    NSArray         *constraints    = [self subdirectives];
    LDrawDirective  *currentCommand = nil;
    NSString		*commandString	= nil;
    NSUInteger      numberCommands  = 0;
    NSUInteger      counter         = 0;
    NSUserDefaults *userDefaults    = [NSUserDefaults standardUserDefaults];
    
    // Start

    [written appendFormat:@"0 SYNTH BEGIN %@ %d%@", [self lsynthType], (int)[self->color colorCode], CRLF];
    [written appendFormat:@"0 SYNTH %@%@", lsynthVisibility, CRLF];

    numberCommands  = [constraints count];
    for(counter = 0; counter < numberCommands; counter++)
    {
        currentCommand = [constraints objectAtIndex:counter];
        commandString = [currentCommand write];
        [written appendString:commandString];
        [written appendString:CRLF];
    }

    // Write out synthesized parts, if there are any to write out
    if ([self->synthesizedParts count] > 0
        && [userDefaults integerForKey:LSYNTH_SAVE_SYNTHESIZED_PARTS_KEY] == YES) {
        [written appendString:@"0 SYNTH SYNTHESIZED BEGIN"];
        [written appendString:CRLF];
        for (LDrawPart *part in self->synthesizedParts) {
            // Parts aren't smart enough to know that they're temporarily coloured differently
            // during Synth part selection, so we force the parent color in.  It's reset when the
            // part selection changes, anyway.
            [part setLDrawColor:self->color];
            [written appendString:[part write]];
            [written appendString:CRLF];
        }
        [written appendString:@"0 SYNTH SYNTHESIZED END"];
        [written appendString:CRLF];
    }
    // End
    [written appendString:@"0 SYNTH END"];
    [written appendString:CRLF];

    return written;
}//end write

#pragma mark -
#pragma mark DISPLAY
#pragma mark -

//========== browsingDescription ===============================================
//
// Purpose:		Returns a representation of the directive as a short string
//				which can be presented to the user.
//
//==============================================================================
- (NSString *) browsingDescription
{
    LSynthConfiguration	*config			= [LSynthConfiguration sharedInstance];
	NSDictionary		*entry			= [config typeForTypeName:self->synthType];
	NSString			*description	= nil;
	
	if(entry)
		description = [entry objectForKey:@"title"];
	
	if(description == nil)
		description = self->synthType;
	
    // Show the number of parts
    // TODO: allow for single-piece objects like tubes/string etc.  Meanwhile just show the part type
    // The part type's <fill> param (FIXED or STRETCH( should serve in deciding this.
    //return [NSString stringWithFormat:@"%@ (%i pieces)", self->synthType, [synthesizedParts count]];
    return description;

}//end browsingDescription

//========== iconName ==========================================================
//
// Purpose:		Returns the name of image file used to display this kind of
//				object, or nil if there is no icon.
//
//==============================================================================
- (NSString *) iconName
{
    return @"LSynthPart";

}//end iconName

#pragma mark -
#pragma mark ACCESSORS
#pragma mark -

//========== boundingBox3 ======================================================
//
// Purpose:		Returns the minimum and maximum points of the box which
//				perfectly contains this object.
//
//==============================================================================
- (Box3) boundingBox3 {
    if ([self revalCache:CacheFlagBounds] == CacheFlagBounds)
    {
        cachedBounds = [LDrawUtilities boundingBox3ForDirectives:[self subdirectives]];
    }
    return cachedBounds;
}

//========== setLsynthClass: ====================================================
//
//  Purpose:		Sets the class of the Synthesized part, Pneumatic tube, or Technic
//                  chain etc.
//
//==============================================================================
- (void) setLsynthClass:(int)class
{
    self->lsynthClass = class;
}//end setLsynthClass:

//========== lsynthClass: ====================================================
//
//  Purpose:		Return the class of the Synthesized part.
//
//==============================================================================

- (int) lsynthClass
{
    return self->lsynthClass;
}//end lsynthClass:

//========== setLsynthType: ====================================================
//
//  Purpose:		Sets the type of the Synthesized part, band, chain or part
//
//==============================================================================
- (void) setLsynthType:(NSString *)type
{
    self->synthType = type;

}//end setLsynthType:

//========== lsynthClass: ====================================================
//
//  Purpose:		Return the type of the Synthesized part.
//
//============================================================================
- (NSString *) lsynthType
{
    return self->synthType;
}//end

//========== setHidden: ========================================================
//
// Purpose:		Sets whether this part will be drawn, or whether it will be
//				skipped during drawing. This setting only affects drawing;
//				hidden parts will always be written out. Also, note that
//				hiddenness is a temporary state; it is not saved and restored.
//
//==============================================================================
- (void) setHidden:(BOOL) flag
{
    if(self->hidden != flag)
    {
        self->hidden = flag;
        [self invalCache:(CacheFlagBounds|DisplayList)];
    }

}//end setHidden:

//========== isHidden ==========================================================
//
// Purpose:		Returns whether this element will be drawn or not.
//
//==============================================================================
- (BOOL) isHidden
{
    return self->hidden;

}//end isHidden

//========== transformComponents ===============================================
//
// Purpose:		Returns the individual components of the transformation matrix
//			    applied to this part.
//
//==============================================================================
- (TransformComponents) transformComponents
{
    Matrix4				transformation	= [self transformationMatrix];
    TransformComponents	components		= IdentityComponents;

    //This is a pretty darn neat little function. I wish I could say I wrote it.
    // It will extract all the user-friendly components out of this nasty matrix.
    Matrix4DecomposeTransformation( transformation, &components );

    return components;

}//end transformComponents

//========== setSelected: ======================================================
//
// Purpose:		Custom (de)selection action.  We want to make our part transparent
//              when selected.
//
//==============================================================================
- (void) setSelected:(BOOL)flag
{
    [super setSelected:flag];
    // We don't need to resynthesize just to change the colours
    [self colorSelectedSynthesizedParts:flag];
}//end setSelected:

//========== setSubdirectiveSelected: =========================================
//
// Purpose:		Set the flag denoting whether a subdirective is selected
//              Also colors the synthesized parts translucent
//
//==============================================================================
- (void) setSubdirectiveSelected:(BOOL)flag
{
    self->subdirectiveSelected = flag;
    [self colorSelectedSynthesizedParts:flag];
}

#pragma mark <LDrawColorable> protocol methods

//========== setLDrawColor: ====================================================
//
// Purpose:		Sets the color of the synthesized tube.  This may be temporarily
//              overridden for certain operations but WILL be the one saved out.
//
//==============================================================================
- (void) setLDrawColor:(LDrawColor *)newColor
{
    // Store the color
    self->color = newColor;

    [self colorSelectedSynthesizedParts:[self isSelected]];
}//end setLDrawColor:

//========== LDrawColor ========================================================
//
// Purpose:		Returns the LDraw color code of the receiver.
//
//==============================================================================
-(LDrawColor *) LDrawColor
{
    return color;
}//end LDrawColor

#pragma mark -
#pragma mark <LDrawMovableElement> protocol methods
#pragma mark -

//========== displacementForNudge: =============================================
//
// Purpose:		Determine the displacement for a specific nudge.  We rely on the
//              first subdirective that can help; all subdirectives will move
//              same amount.
//
//==============================================================================
- (Vector3) displacementForNudge:(Vector3)nudgeVector
{
    for (id directive in [self subdirectives]) {
         if ([directive isKindOfClass:[LDrawDrawableElement class]] &&
             [directive conformsToProtocol:@protocol(LDrawMovableDirective)]) {
             return [directive displacementForNudge:nudgeVector];
         }
    }
    Vector3 v = {0,0,0};
    return v;

}

//========== moveBy: ===========================================================
//
// Purpose:		Passes a movement request down to its subdirectives
//
// Optimisation: move all synthesized elements as well to save a resynth
//
//==============================================================================
- (void) moveBy:(Vector3)moveVector
{
    // pass on the nudge to drawable subdirectives
    for (LDrawDirective * constraint in [self subdirectives]) {
        if([constraint conformsToProtocol:@protocol(LDrawMovableDirective)])  {
            [(LDrawPart *)constraint moveBy:moveVector];
        }
    }
}//end moveBy:


#pragma mark -
#pragma mark UTILITY FUNCTIONS
#pragma mark -

//========== synthesize ========================================================
//
// Purpose:	Synthesizes the part using LSynth
//
// TODO: multithread/background
//
//==============================================================================
-(void)synthesize
{
    //NSLog(@"SYNTHESIZE");

    // Modifies the constraints to provide automatic OUTSIDE/INSIDE determination for
    // constraints inside the convex hull.  Dig down for more details.
    BOOL doAutoHull = YES; // Placeholder until we make it a configurable setting
    if (doAutoHull == YES && self->lsynthClass == LSYNTH_BAND) {
        // TODO: Turned off while the Inspector code is fleshed out
        //[self doAutoHullOnBand];
    }

    // Clean up first
    [synthesizedParts removeAllObjects];

    NSString *input = @"";
    Class CommandClass = Nil;

    // Path to lsynth.  If it's unset or whitespace use the built-in default
    NSUserDefaults *userDefaults   = [NSUserDefaults standardUserDefaults];
    NSString       *executablePath = [userDefaults stringForKey:LSYNTH_EXECUTABLE_PATH_KEY];
    NSString       *configPath     = [userDefaults stringForKey:LSYNTH_CONFIGURATION_PATH_KEY];
    NSString       *lsynthPath;
    if ([executablePath length] == 0 || [executablePath isMatchedByRegex:@"^\\s+$"]) {
        lsynthPath = [[NSBundle mainBundle] pathForAuxiliaryExecutable:@"lsynthcp"];
    }
    else {
        lsynthPath = executablePath;
    }

    // We run LSynth as follows:
    // - Create an LDraw file in memory
    // - Setup the STDIN/OUT pipes and NSTask
    // - Launch task
    // - Write to LSynth's STDIN, read from its STDOUT
    // - Process the output (using LDrawDirective's parser) into synthesized parts

    // Create an LDraw file in memory
    LDrawColorT code = self->subdirectiveSelected ? LDrawClear : [[self LDrawColor] colorCode] ;
    input = [input stringByAppendingFormat:@"0 SYNTH BEGIN %@ %d\n", self->synthType, code];
    input = [input stringByAppendingFormat:@"0 SYNTH %@\n", @"SHOW"]; // TODO: honour visibility?
    for (LDrawPart *part in [self subdirectives]) {
        input = [input stringByAppendingFormat:@"%@\n", [part write]];
    }
    input = [input stringByAppendingString:@"0 SYNTH END\n"];
    input = [input stringByAppendingString:@"0 STEP\n"];

    // Setup the STDIN/OUT pipes and NSTask
    NSTask *task = [[NSTask alloc] init];
    NSPipe *inPipe = nil;
    NSPipe *outPipe = nil;
    NSPipe *errorPipe = nil;
    NSFileHandle *inFile;
    NSFileHandle *outFile;
    NSFileHandle *errorFile;

    inPipe    = [NSPipe new];
    outPipe   = [NSPipe new];
    errorPipe = [NSPipe new];

    // Add custom configuration arguments if required
    NSMutableArray *arguments = [[NSMutableArray alloc] init];
    if ([configPath length]) {
        [arguments addObjectsFromArray:[NSArray arrayWithObjects:@"-c", configPath, nil]];
    }
    [arguments addObject:@"-"]; // Our built-in LSynth accepts STDIN/STDOUT with this argument
    
    [task setStandardInput:inPipe];
    [task setStandardOutput:outPipe];
    [task setStandardError:errorPipe];
    [task setLaunchPath:lsynthPath];
    [task setArguments:arguments];
    //    [task setArguments:[NSArray arrayWithObject:@"-"]]; // Our built-in LSynth accepts STDIN/STDOUT with this argument

    inFile = [inPipe fileHandleForWriting];
    outFile = [outPipe fileHandleForReading];
    errorFile = [errorPipe fileHandleForReading];

    // Launch the task
    [task launch];

    // Write the LSynth part to LSynth's STDIN
    [inFile writeData: [input dataUsingEncoding: NSASCIIStringEncoding]];
    [inFile closeFile];

    // Read standard error - causing a race condition?
//    NSMutableData *errorData = [[NSMutableData alloc] init];
//    NSData *readErrorData;
//
//    while ((readErrorData = [errorFile availableData])
//            && [readErrorData length]) {
//        [errorData appendData: readErrorData];
//    }
//
//    NSString *lsynthErrorOutput;
//    lsynthErrorOutput = [[NSString alloc]
//            initWithData: errorData
//                encoding: NSASCIIStringEncoding];
//
//    if ([lsynthErrorOutput length]) {
//        NSLog(@"LSynth generated standard error output:\n%@", lsynthErrorOutput);
//    }

    // Read the synthesized file back in from LSynth's STDOUT
    NSMutableData *data = [[NSMutableData alloc] init];
    NSData *readData;

    while ((readData = [outFile availableData])
            && [readData length]) {
        [data appendData: readData];
    }

    NSString *lsynthOutput;
    lsynthOutput = [[NSString alloc]
            initWithData: data
                encoding: NSASCIIStringEncoding];

    // Split the output into lines
    NSMutableArray *stringsArray = [NSMutableArray arrayWithArray:[lsynthOutput
            componentsSeparatedByCharactersInSet:[NSCharacterSet newlineCharacterSet]]];

    // Process the synthesized parts
    BOOL extract = NO;

    for (NSString *line in stringsArray) {
        NSRange startRange = [line rangeOfString:@"0 SYNTH SYNTHESIZED BEGIN"];
        NSRange partRange = [line rangeOfString:@"1"];

        if (extract == YES && partRange.length > 0 && partRange.location == 0) {
            CommandClass = [LDrawUtilities classForDirectiveBeginningWithLine:line];
            LDrawDirective *newDirective = [[CommandClass alloc] initWithLines:[NSArray arrayWithObject:line]
                                                                       inRange:NSMakeRange(0, 1)
                                                                   parentGroup:nil];
            [synthesizedParts addObject:newDirective];
        } else if (extract == NO && startRange.length > 0)  {
            extract = YES;
        }
    }
}
//========== doAutoHullOnBand ==================================================
//
// Purpose:	Calculate the INSIDE/OUTSIDE directives automatically.
//
//          Based on calculating the convex hull of the constraints and inserting
//          INSIDE/OUTSIDE directives appropriately.
//
//==============================================================================
- (void)doAutoHullOnBand
{
    // clean out INSIDE/OUTSIDE directives
    int i;
    for (i = [[self subdirectives] count] - 1; i >= 0; i--) {
        if ([[[self subdirectives] objectAtIndex:i] isKindOfClass:[LDrawLSynthDirective class]]) {
            [[self subdirectives] removeObjectAtIndex:i];
        }
    }
    //NSLog(@"Cleaned subdirs: %@", [self subdirectives]);

    // Prepare the constraints for calculating the convex hull.
    NSMutableArray *preparedData = [self prepareAutoHullData];

    // Determine the Convex Hull.  This is the meat.  After this we know
    // which constraints are really on the hull.  We respect their radii..
    [ComputationalGeometry doJarvisMarch:preparedData];

    //NSLog(@"Prepared Data After: %@", preparedData);

    // Reintegrate our hull-determined data.  We'll likely have multiple
    // points all on the hull, each associated with a single constraint.
    // This boils them down to a set of constraints on the hull.
    NSMutableSet *hullConstraints = [[NSMutableSet alloc] init];
    for (NSMutableDictionary *point in preparedData) {
        if ([[point objectForKey:@"inHull"] integerValue] == YES) {
            [hullConstraints addObject:[point objectForKey:@"directive"]];
        }
    }
    //NSLog(@"hullConstraints: %@", hullConstraints);

    // Knowing which constraints are on the hull allows us to add
    // INSIDE/OUTSIDE constraints as we iterate over them.
    // We could modify the constraints in-place but recreating the
    // subdirectives array is simpler.
    NSMutableArray *newConstraints = [[NSMutableArray alloc] init];

    for (i=0; i<[[self subdirectives] count]; i++) {
        LDrawPart *part = [[self subdirectives] objectAtIndex:i];
        LDrawPart *nextPart = [[self subdirectives] objectAtIndex:((i+1) % [[self subdirectives] count])];

        // The first point is potentially a special case.  Handle it.
        // Not on the hull? Then prepend an OUTSIDE
        if (i == 0 && ![hullConstraints containsObject:part]) {
            LDrawLSynthDirective *OUTSIDE = [[LDrawLSynthDirective alloc] init];
            [OUTSIDE setStringValue:@"OUTSIDE"];
            [newConstraints addObject:OUTSIDE];
        }

        // This part is on the hull (i.e. INSIDE the band) and the next part is
        // NOT on hull (i.e. OUTSIDE)
        if ( [hullConstraints containsObject:part] &&
            ![hullConstraints containsObject:nextPart]) {
            // generate OUTSIDE
            LDrawLSynthDirective *OUTSIDE = [[LDrawLSynthDirective alloc] init];
            [OUTSIDE setStringValue:@"OUTSIDE"];
            [newConstraints addObject:part];
            [newConstraints addObject:OUTSIDE];
        }

        // This part is not on the hull (i.e. OUTSIDE the band) and the next part IS
        // on hull (i.e. INSIDE)
        else if ( ![hullConstraints containsObject:part] &&
                [hullConstraints containsObject:nextPart]){
            // generate INSIDE
            LDrawLSynthDirective *INSIDE = [[LDrawLSynthDirective alloc] init];
            [INSIDE setStringValue:@"INSIDE"];
            [newConstraints addObject:part];
            [newConstraints addObject:INSIDE];
        }

        // The constraint has the same hull membership as the next one so
        // no change of direction.  Just add it.
        else {
            [newConstraints addObject:part];
        }

        //NSLog(@"New Constraints: %@", newConstraints);
    }

    // Finally, update the constraints
    [[self subdirectives] removeAllObjects];
    [[self subdirectives] addObjectsFromArray:newConstraints];
}

//========== prepareAutoHullData ===============================================
//
// Purpose:	Prepare a datastructure containing points, directives etc., ready for
//          calculating the convex hull.
//
//==============================================================================
- (NSMutableArray *)prepareAutoHullData {

    // Used for looking up constraint radii
    LSynthConfiguration *config = [LSynthConfiguration sharedInstance];

    // Map each constraint to XY plane, based on the orientation of the first constraint
    // We build up details for each constraint in mappedPoints as we progress.
    // The inverse of the first constraint's transformation moves it back to (0,0,0).
    // The same inverse transform will do similar for the other constraints
    NSMutableArray *mappedPoints = [[NSMutableArray alloc] init];
    Matrix4 transform = [[[self subdirectives] objectAtIndex:0] transformationMatrix];
    Matrix4 inverseTransform = Matrix4Invert(transform);
    for (LDrawPart *part in [self subdirectives]) {
        Matrix4 transformed;
        transformed = Matrix4Multiply([part transformationMatrix], inverseTransform);
        TransformComponents t;
        Matrix4DecomposeTransformation(transformed, &t);
        NSMutableDictionary *point = [NSMutableDictionary
            dictionaryWithObjects:[NSArray
                arrayWithObjects:part,
                                 [NSNumber numberWithFloat:t.translate.x],
                                 [NSNumber numberWithFloat:t.translate.y],
                                 [NSNumber numberWithInt:[[[config constraintDefinitionForPart:part] valueForKey:@"radius"] integerValue]],
                                 [NSMutableArray array],
                                 nil]
                         forKeys:[NSArray arrayWithObjects:@"directive", @"x", @"y", @"r", @"hullPoints", nil]];
        [mappedPoints addObject:point];
    }
    //NSLog(@"Mapped Points: %@", mappedPoints);

    // Generate hull points by calculating "outside" tangents for each pair of
    // constraint-derived circles, e.g. ((0,1), (1,2), ..., (N,0)
    // Some of these will be on the inside of the convex hull but that's OK since the
    // convex hull calculation will discard them.
    // TODO: can we  take advantage of CCW ordering of constraints?
    int i;
    for (i=0; i<[mappedPoints count]; i++) {
        int j = (i+1) % [mappedPoints count]; // next constraint, cyclical (N+1 -> 0)

        NSArray *tangents = [ComputationalGeometry tangentBetweenCircle:[mappedPoints objectAtIndex:i]
                                                                     andCircle:[mappedPoints objectAtIndex:j]];
        if (tangents != nil) {
            // Tangents are between two circles (i.e. constraints)
            // add both outside tangent points for the current constraint
            [[[mappedPoints objectAtIndex:i] objectForKey:@"hullPoints"] addObject:
                [NSDictionary dictionaryWithObjects:[NSArray arrayWithObjects:[[tangents objectAtIndex:0] objectAtIndex:0],
                                                                              [[tangents objectAtIndex:0] objectAtIndex:1], nil]
                                            forKeys:[NSArray arrayWithObjects:@"x", @"y", nil]]];

            [[[mappedPoints objectAtIndex:i] objectForKey:@"hullPoints"] addObject:
                    [NSDictionary dictionaryWithObjects:[NSArray arrayWithObjects:[[tangents objectAtIndex:1] objectAtIndex:0],
                                                                                  [[tangents objectAtIndex:1] objectAtIndex:1], nil]
                                                forKeys:[NSArray arrayWithObjects:@"x", @"y", nil]]];

            // add both outside tangent points for the next constraint
            [[[mappedPoints objectAtIndex:j] objectForKey:@"hullPoints"] addObject:
                    [NSDictionary dictionaryWithObjects:[NSArray arrayWithObjects:[[tangents objectAtIndex:0] objectAtIndex:2],
                                                                                  [[tangents objectAtIndex:0] objectAtIndex:3], nil]
                                                forKeys:[NSArray arrayWithObjects:@"x", @"y", nil]]];

            [[[mappedPoints objectAtIndex:j] objectForKey:@"hullPoints"] addObject:
                    [NSDictionary dictionaryWithObjects:[NSArray arrayWithObjects:[[tangents objectAtIndex:1] objectAtIndex:2],
                                                                                  [[tangents objectAtIndex:1] objectAtIndex:3], nil]
                                                forKeys:[NSArray arrayWithObjects:@"x", @"y", nil]]];
        }

        //NSLog(@"Tangents: %@", tangents);
    }
    //NSLog(@"Mapped Points after tangent calc: %@", mappedPoints);

    // Prepare the mappedPoints for the Convex Hull algorithm
    // We create a dictionary for each hull point for each mappedPoint
    // We'll reintegrate later to decide which constraints are in or out
    // (in doAutoHullOnBand)
    NSMutableArray *preparedData = [[NSMutableArray alloc] init];
    for (NSMutableDictionary *point in mappedPoints) {
        for (NSMutableDictionary *coords in [point objectForKey:@"hullPoints"]) {
            //NSLog(@"Point: %@", coords);
            // TODO: check that int values are OK.  Prob. should use float?

            [preparedData addObject:[NSMutableDictionary
                dictionaryWithObjects:[NSArray arrayWithObjects:[point objectForKey:@"directive"],
                    [NSNumber numberWithInt:[[coords objectForKey:@"x"] integerValue]],
                    [NSNumber numberWithInt:[[coords objectForKey:@"y"] integerValue]],
                    [NSNumber numberWithBool:false],
                    nil]
                forKeys:[NSArray arrayWithObjects:@"directive", @"x", @"y", @"inHull", nil]]];
        }
    }
    //NSLog(@"Prepared Data: %@", preparedData);
    return preparedData;
}//end prepareAutoHullData

//========== determineIconName: ================================================
//
// Purpose:		Determine the name of the constraint icon depending on the type
//              of synthesized part.
//
//==============================================================================

-(NSString *)determineIconName:(LDrawDirective *)directive
{
    // Hose
    if (self->lsynthClass == LSYNTH_HOSE) {
        return @"LSynthHoseConstraint";
    }

    // Band
    else if (self->lsynthClass == LSYNTH_BAND) {
        return @"LSynthBandConstraint";
    }

    // Part
    else if (self->lsynthClass == LSYNTH_PART) {
        if ([self partClass] == LSYNTH_HOSE) {
            return @"LSynthHoseConstraint";
        }
        else if ([self partClass] == LSYNTH_BAND) {
            return @"LSynthBandConstraint";
        }
    }

    // Other?
    return @"Brick";
}//end determineIconName:

//========== colorSelectedSynthesizedParts: ====================================
//
// Purpose:		Change the appearance of selected synthesized parts according
//              to user preferences so that they can better see the object and
//              its constraints.
//
//==============================================================================
- (void)colorSelectedSynthesizedParts:(BOOL)yesNo
{
    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
    LSynthSelectionModeT selectionMode = [userDefaults integerForKey:LSYNTH_SELECTION_MODE_KEY];
    GLfloat rgba[4]; // a temporary RGBA color we create and manipulate
    LDrawColor *theColor = [[LDrawColor alloc] init]; // an LDrawColor to set the part's color with

    // Is the part selected?
    if (yesNo == YES) {

        // Modify the transparency, but use the object's existing color
        if (selectionMode == TransparentSelection) {
            [color getColorRGBA:rgba];
            rgba[3] = ((float)[userDefaults integerForKey:LSYNTH_SELECTION_TRANSPARENCY_KEY]) / 100;
        }

        // Modify the color, with full opacity/no transparency
        else if (selectionMode == ColoredSelection) {
            NSColor *selectionColor = [userDefaults colorForKey:LSYNTH_SELECTION_COLOR_KEY];
            rgba[0] = [selectionColor redComponent];
            rgba[1] = [selectionColor greenComponent];
            rgba[2] = [selectionColor blueComponent];
            rgba[3] = 1.0; // fully opaque
        }

        // Modify both color and transparency
        else if (selectionMode == TransparentColoredSelection) {
            NSColor *selectionColor = [userDefaults colorForKey:LSYNTH_SELECTION_COLOR_KEY];
            rgba[0] = [selectionColor redComponent];
            rgba[1] = [selectionColor greenComponent];
            rgba[2] = [selectionColor blueComponent];
            rgba[3] = ((float)[userDefaults integerForKey:LSYNTH_SELECTION_TRANSPARENCY_KEY]) / 100;
        }

        [theColor setColorRGBA:rgba];
    }

    // The part's not selected so use its actual color
    else {
        theColor = color;
    }

    // Recolor the synthesized parts
    for (LDrawPart *part in self->synthesizedParts) {
        [part setLDrawColor:theColor];
    }

} //end colorSelectedSynthesizedParts:

//========== transformationMatrix ==============================================
//
// Purpose:		Returns a two-dimensional (row matrix) representation of the
//				part's transformation matrix.
//
//																+-       -+
//				+-                           -+        +-     -+| a d g 0 |
//				|a d g 0 b e h c f i 0 x y z 1|  -->   |x y z 1|| b e h 0 |
//				+-                           -+        +-     -+| c f i 0 |
//																| x y z 1 |
//																+-       -+
//					  OpenGL Matrix Format                 LDraw Matrix
//				(flat column-major of transpose)              Format
//
//==============================================================================
- (Matrix4) transformationMatrix
{
    return Matrix4CreateFromGLMatrix4(glTransformation);

}//end transformationMatrix

//========== acceptsDroppedDirective: ==========================================
//
// Purpose:		Returns YES if this container will accept a directive dropped on
//              it.
//
//==============================================================================
-(BOOL)acceptsDroppedDirective:(LDrawDirective *)directive
{
    // Only add valid parts as constraints; invalid ones are passed to our container
    // This arises if a synth part is selected and a part is dragged from the
    // part chooser to the view.
    if (	([directive isKindOfClass:[LDrawPart class]] && [[LSynthConfiguration sharedInstance] isLSynthConstraint:(LDrawPart*)directive])
        ||	[directive isKindOfClass:[LDrawLSynthDirective class]])
	{
        return YES;
    }
    return NO;
}


//========== cleanupAfterDrop ====================================================
//
// Purpose:		Called as part of a drag and drop operation.
//              The argument indicates whether we were a donating parent or not.
//              this in turn affect whether we should be selected.
//
// TODO: Should be a protocol
//
//==============================================================================
-(void)cleanupAfterDropIsDonor:(NSNumber *)isDonor
{
    [self setSelected:NO];

    if ([isDonor boolValue] == NO) {
        [self setSubdirectiveSelected:YES];
    }
} //end cleanupAfterDrop

//========== synthesizedPartsCount =============================================
//
// Purpose:		Returns the number of parts synthesized to create the shape.
//
//==============================================================================
-(int)synthesizedPartsCount
{
    return [synthesizedParts count];
}

//========== partClass =========================================================
//
// Purpose:		Returns the class of a part
//              TODO: Optimise part class determination into a config dict and
//              remove the loops.
//
//==============================================================================
-(LSynthClassT)partClass
{
	LSynthClassT class = self->lsynthClass;
	
    if (self->lsynthClass == LSYNTH_PART) {
        NSArray *partTypes = [[LSynthConfiguration sharedInstance] getParts];

        // Loop over the parts from config, and when we find one matching ourselves
        // use that part's class.
        for (NSDictionary *part in partTypes) {
            if ([[self lsynthType] isEqualToString:[part valueForKey:@"LSYNTH_TYPE"]]) {
                class = [[part valueForKey:@"LSYNTH_CLASS"] integerValue];
				break;
            }
        }
    }
	else
	{
		// For some reason we've been called when we're not a Part so trust that
		// we have the correct class.
	}

	return class;
}


#pragma mark -
#pragma mark NOTIFICATIONS
#pragma mark -

//========== receiveMessage:who: ===============================================
//
// Purpose:		The things we observe call this when something one-time and
//				eventful happens - we can respond if desired.
//
//==============================================================================
- (void) receiveMessage:(MessageT) msg who:(id<LDrawObservable>) observable
{
    // Typically if one of our child constraints changed we need to resynthesize
    if (msg == MessageObservedChanged) {
        [self invalCache:ContainerInvalid];
    }
} //end receiveMessage:who:

//========== selectionDisplayOptionsDidChange: =================================
//
// Purpose:		The selection style has changed, so we may need to redraw.
//              We get here via a LSynthSelectionDisplayDidChangeNotification
//              probably sent from the preferences controller.
//
//==============================================================================
-(void)selectionDisplayOptionsDidChange:(id)sender
{
    [self colorSelectedSynthesizedParts:([self isSelected] || self->subdirectiveSelected)];
    [self noteNeedsDisplay];
} // end selectionDisplayOptionsDidChange:

//========== requiresResynthesis: ==============================================
//
// Purpose:		LSynth parts need resynthesized explicitly for some reason.
//              We get here via a LSynthResynthesisRequiredNotification
//              probably sent from the preferences controller in response to an
//              executable or config file change.
//
//==============================================================================
-(void)requiresResynthesis:(id)sender
{
    [self synthesize];
    [self colorSelectedSynthesizedParts:([self isSelected] || self->subdirectiveSelected)];
    [self noteNeedsDisplay];
} // end requiresResynthesis:

@end
